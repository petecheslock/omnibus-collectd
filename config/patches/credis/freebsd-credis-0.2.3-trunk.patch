diff -rupN credis-0.2.3/Makefile credis-trunk/Makefile
--- credis-0.2.3/Makefile	2010-08-27 04:57:25.000000000 -0400
+++ credis-trunk/Makefile	2014-01-17 11:40:17.000000000 -0500
@@ -1,6 +1,20 @@
-CFLAGS = -g -O2 -Wall
-LDFLAGS =
-#CPPFLAGS = -DPRINTDEBUG
+CFLAGS ?= -g -O2 -Wall
+LDFLAGS ?=
+#CPPFLAGS += -DPRINTDEBUG
+
+VER_MAJOR = 0
+VER_MINOR = 3
+VER_PATCH = 0
+VER=$(VER_MAJOR).$(VER_MINOR).$(VER_PATCH)
+
+INSTALL ?= /usr/bin/install -c
+MKDIR ?= /bin/mkdir -p
+CP ?= /bin/cp -fd
+LN ?= /bin/ln -fs
+
+INSTALLDIR ?= /usr/local
+LIBDIR = $(INSTALLDIR)/lib
+INCLUDEDIR = $(INSTALLDIR)/include
 
 # build shared lib under OS X or Linux
 OS = $(shell uname -s)
@@ -22,12 +36,19 @@ libcredis.a: credis.o
 	$(AR) -cvq $@ $^
 
 libcredis.so: credis.o
-	$(CC) $(SHAREDLIB_LINK_OPTIONS)$@ -o $@ $^
+	$(CC) $(SHAREDLIB_LINK_OPTIONS)$@.$(VER_MAJOR) -o $@.$(VER) $^
+	$(LN) $@.$(VER) $@.$(VER_MAJOR)
+	$(LN) $@.$(VER_MAJOR) $@
 
 credis.o: credis.c credis.h Makefile
 	$(CC) -c -fPIC $(CFLAGS) $(CPPFLAGS) -o $@ credis.c
 
-install:
-	@echo "Installing library (to be done)"
+install: all installdirs
+	$(INSTALL) -m644 *.h $(INCLUDEDIR)
+	$(INSTALL) -m755 *.so* *.a $(LIBDIR)
+
+installdirs:
+	$(MKDIR) $(LIBDIR) $(INCLUDEDIR)
+
 clean:
-	rm -f *.o *~ $(TARGETS)
+	rm -f *.o *~ *.so* $(TARGETS)
diff -rupN credis-0.2.3/credis-test.c credis-trunk/credis-test.c
--- credis-0.2.3/credis-test.c	2010-08-27 04:57:25.000000000 -0400
+++ credis-trunk/credis-test.c	2014-01-17 11:41:01.000000000 -0500
@@ -1,7 +1,7 @@
 /* credis-test.c -- a sample test application using credis (C client library 
  * for Redis)
  *
- * Copyright (c) 2009-2010, Jonas Romfelt <jonas at romfelt dot se>
+ * Copyright (c) 2009-2012, Jonas Romfelt <jonas at romfelt dot se>
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -33,6 +33,7 @@
 #include <stdlib.h>
 #include <string.h>
 #include <sys/time.h>
+#include <unistd.h>
 
 #include "credis.h"
 
@@ -71,6 +72,439 @@ void randomize()
 #define DUMMY_DATA "some dummy data string"
 #define LONG_DATA 50000
 
+static int test_cases, test_cases_failed, total_tests, total_fails, test_case_result;
+
+#define EXPECT_TRUE(expression)					\
+  test_expect_true(expression, #expression, __FILE__, __LINE__)
+
+#define EXPECT_EQ(expression, value)					\
+  test_expect_eq(expression, #expression, __FILE__, __LINE__, value)
+
+#define EXPECT_LT(expression, value)					\
+  test_expect_lt(expression, #expression, __FILE__, __LINE__, value)
+
+#define EXPECT_GT(expression, value)					\
+  test_expect_gt(expression, #expression, __FILE__, __LINE__, value)
+
+#define TEST_GROUP(name)						\
+  printf("\nSECTION: %.*s\n\n",						\
+	 60, name" <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<");
+
+#define TEST_BEGIN(name)			\
+  test_begin(name)
+
+#define TEST_DONE()				\
+  test_done()
+
+#define TEST_RESULT()				\
+  test_result()
+
+void test_begin(const char *name)
+{
+  test_case_result = 0;
+  printf("TEST #%03d: %s\n", ++test_cases, name);
+}
+
+int test_done(void)
+{
+  if (test_case_result) {
+    test_cases_failed++;
+    total_fails += test_case_result;
+    printf("\tFAILED\n");
+    
+    return -1;
+  }
+  
+  printf("\tOK\n");
+    
+  return 0;
+}
+
+//#define SHOW_POSITIVE_EXPECTS 1
+
+int test_expect_true(int result, const char *expression, const char *file, int line)
+{
+  total_tests++;
+  if (!result) {
+    test_case_result++;
+    printf("\tEXPECT_TRUE FAIL (%s) == FALSE @ %s:%d\n", expression, file, line);
+  }
+#ifdef SHOW_POSITIVE_EXPECTS
+  else
+    printf("\tEXPECT_TRUE OK (%s) == TRUE\n", expression);
+#endif
+
+  return result;
+}  
+
+int test_expect_eq(int result, const char *expression, const char *file, int line, int value)
+{
+  total_tests++;
+  if (result != value) {
+    test_case_result++;
+    printf("\tEXPECT_EQ FAIL (%s = %d) != %d @ %s:%d\n", 
+	   expression, result, value, file, line);
+  }
+#ifdef SHOW_POSITIVE_EXPECTS
+  else
+    printf("\tEXPECT_EQ OK %s == %d\n", expression, value);
+#endif
+
+  return result;
+}  
+
+int test_expect_lt(int result, const char *expression, const char *file, int line, int value)
+{
+  total_tests++;
+  if (result >= value) {
+    test_case_result++;
+    printf("\tEXPECT_LT FAIL (%s = %d) >= %d @ %s:%d\n", 
+	   expression, result, value, file, line);
+  }
+#ifdef SHOW_POSITIVE_EXPECTS
+  else
+    printf("\tEXPECT_LT OK (%s = %d) < %d\n", expression, result, value);
+#endif
+
+  return result;
+}  
+
+int test_expect_gt(int result, const char *expression, const char *file, int line, int value)
+{
+  total_tests++;
+  if (result <= value) {
+    test_case_result++;
+    printf("\tEXPECT_GT FAIL (%s = %d) <= %d @ %s:%d\n", 
+	   expression, result, value, file, line);
+  }
+#ifdef SHOW_POSITIVE_EXPECTS
+  else
+    printf("\tEXPECT_GT OK (%s = %d) > %d\n", expression, result, value);
+#endif
+
+  return result;
+}  
+
+void test_result(void)
+{
+  printf("RESULT:\n\t%d test cases run, %d passed, %d failed\n",
+	 test_cases, test_cases - test_cases_failed, test_cases_failed); 
+
+  printf("\t%d tests run in total, %d passed, %d failed\n\n", 
+	 total_tests, total_tests - total_fails, total_fails);
+}
+
+int test_suite2(void)
+{
+  REDIS redis;
+  REDIS_INFO info;
+  char *val, **valv, lstr[50000];
+  const char *keys[] = {"key1", "key2", "key3", "key4", "key5"};
+  const char *values[] = {"abcdefg", "hijklmn", "opqr", "stuvw", "xyz"};
+  int rc, keyc=5, i, value;
+  double score1, score2;
+
+  TEST_GROUP("redis connection");
+
+  TEST_BEGIN("connect");
+  EXPECT_TRUE((redis = credis_connect(NULL, 0, 10000)) != NULL);
+  credis_close(redis);
+  TEST_DONE();
+  
+  TEST_BEGIN("quit");
+  EXPECT_TRUE((redis = credis_connect(NULL, 0, 10000)) != NULL);
+  EXPECT_EQ(credis_quit(redis), 0);
+  credis_close(redis);
+  TEST_DONE();
+  
+  TEST_BEGIN("connect and stay connected");
+  EXPECT_TRUE((redis = credis_connect(NULL, 0, 10000)) != NULL);
+  TEST_DONE();
+
+  TEST_BEGIN("ping");
+  EXPECT_EQ(credis_ping(redis), 0);
+  TEST_DONE();
+
+  TEST_BEGIN("echo");
+  EXPECT_EQ(credis_echo(redis, "echoooo.....", &val), 0);
+  EXPECT_EQ(strcmp(val, "echoooo....."), 0);
+  TEST_DONE();
+
+  TEST_BEGIN("last save");
+  EXPECT_GT(credis_lastsave(redis), 0);
+  TEST_DONE();
+
+  TEST_BEGIN("info");
+  EXPECT_EQ(credis_info(redis, &info), 0);
+  TEST_DONE();
+
+  TEST_BEGIN("auth");
+  EXPECT_EQ(credis_auth(redis, "qwerty"), 0);
+  EXPECT_EQ(credis_auth(redis, "dvorak"), 0);
+  TEST_DONE();
+
+  TEST_GROUP("string values");
+
+  TEST_BEGIN("set and get");
+  EXPECT_EQ(credis_set(redis, "credis1", "value1"), 0);
+  EXPECT_EQ(credis_set(redis, "credis1", "value1"), 0);
+  EXPECT_EQ(credis_get(redis, "credis1", &val), 0);
+  EXPECT_EQ(strcmp(val, "value1"), 0);
+  TEST_DONE();
+
+  TEST_BEGIN("del");
+  EXPECT_EQ(credis_set(redis, "credis1", "value1"), 0);
+  EXPECT_EQ(credis_del(redis, "credis1"), 0);
+  EXPECT_EQ(credis_del(redis, "credis1"), -1);
+  TEST_DONE();
+
+  TEST_BEGIN("get non-existing");
+  credis_del(redis, "credis1");
+  EXPECT_EQ(credis_get(redis, "credis1", &val), -1);
+  TEST_DONE();
+
+  TEST_BEGIN("getset");
+  credis_del(redis, "credis1");
+  EXPECT_EQ(credis_getset(redis, "credis1", "newvalue1", &val), -1);
+  EXPECT_EQ(credis_set(redis, "credis1", "value1"), 0);
+  EXPECT_EQ(credis_getset(redis, "credis1", "newvalue1", &val), 0);
+  EXPECT_EQ(strcmp(val, "value1"), 0);
+  EXPECT_EQ(credis_get(redis, "credis1", &val), 0);
+  EXPECT_EQ(strcmp(val, "newvalue1"), 0);
+  TEST_DONE();
+
+  TEST_BEGIN("setnx");
+  EXPECT_EQ(credis_del(redis, "credis1"), 0);
+  EXPECT_EQ(credis_setnx(redis, "credis1", "value1"), 0);
+  EXPECT_EQ(credis_setnx(redis, "credis1", "value1"), -1);
+  TEST_DONE();
+
+  TEST_BEGIN("type");
+  EXPECT_EQ(credis_del(redis, "credis1"), 0);
+  EXPECT_EQ(credis_type(redis, "credis1"), CREDIS_TYPE_NONE);
+  EXPECT_EQ(credis_set(redis, "credis1", "value1"), 0);
+  EXPECT_EQ(credis_type(redis, "credis1"), CREDIS_TYPE_STRING);
+  TEST_DONE();
+
+  TEST_BEGIN("setex (1 second)");
+  EXPECT_EQ(credis_setex(redis, "credis1", "value1", 1), 0);
+  EXPECT_EQ(credis_type(redis, "credis1"), CREDIS_TYPE_STRING);
+  sleep(2);
+  EXPECT_EQ(credis_type(redis, "credis1"), CREDIS_TYPE_NONE);
+  TEST_DONE();
+
+  TEST_BEGIN("mget");
+  for (i = 0; i < keyc; i++)
+    credis_set(redis, keys[i], values[i]);
+  EXPECT_EQ(credis_mget(redis, keyc, keys, &valv), keyc);
+  for (i = 0; i < keyc; i++)
+    EXPECT_EQ(strcmp(values[i], valv[i]), 0);
+  TEST_DONE();
+
+  TEST_BEGIN("incr");
+  EXPECT_EQ(credis_set(redis, "credis1", "2"), 0);
+  EXPECT_EQ(credis_incr(redis, "credis1", &value), 0);
+  EXPECT_EQ(value, 3);  
+  TEST_DONE();
+
+  TEST_BEGIN("incrby");
+  EXPECT_EQ(credis_set(redis, "credis1", "30"), 0);
+  EXPECT_EQ(credis_incrby(redis, "credis1", 10, &value), 0);
+  EXPECT_EQ(value, 40);  
+  TEST_DONE();
+
+  TEST_BEGIN("decr");
+  EXPECT_EQ(credis_set(redis, "credis1", "-4"), 0);
+  EXPECT_EQ(credis_decr(redis, "credis1", &value), 0);
+  EXPECT_EQ(value, -5);  
+  TEST_DONE();
+
+  TEST_BEGIN("decrby");
+  EXPECT_EQ(credis_set(redis, "credis1", "30"), 0);
+  EXPECT_EQ(credis_decrby(redis, "credis1", 10, &value), 0);
+  EXPECT_EQ(value, 20);  
+  TEST_DONE();
+
+  TEST_BEGIN("append");
+  EXPECT_EQ(credis_set(redis, "credis1", "12345"), 0);
+  EXPECT_EQ(credis_append(redis, "credis1", "6789"), 9);
+  EXPECT_EQ(credis_get(redis, "credis1", &val), 0);
+  EXPECT_EQ(strcmp(val, "123456789"), 0);
+  EXPECT_EQ(credis_del(redis, "credis1"), 0);
+  EXPECT_EQ(credis_append(redis, "credis1", "123456789"), 9);
+  TEST_DONE();
+
+  TEST_BEGIN("substr");
+  EXPECT_EQ(credis_set(redis, "credis1", "abcdefghijklmnopqrstuvwxyz"), 0);
+  EXPECT_EQ(credis_substr(redis, "credis1", 1, 3, &val), 0);
+  EXPECT_EQ(strcmp(val, "bcd"), 0);
+  EXPECT_EQ(credis_substr(redis, "credis1", -4, -1, &val), 0);
+  EXPECT_EQ(strcmp(val, "wxyz"), 0);
+  TEST_DONE();
+
+  TEST_BEGIN("getrange");
+  EXPECT_EQ(credis_set(redis, "credis1", "abcdefghijklmnopqrstuvwxyz"), 0);
+  EXPECT_EQ(credis_getrange(redis, "credis1", 1, 5, &val), 0);
+  EXPECT_EQ(strcmp(val, "bcdef"), 0);
+  TEST_DONE();
+
+  TEST_GROUP("lists");
+
+  TEST_BEGIN("rphush");
+  credis_del(redis, "credis1");
+  EXPECT_TRUE(credis_rpush(redis, "credis1", "element1") >= 0);
+  EXPECT_TRUE(credis_rpush(redis, "credis1", "element2") >= 0);
+  TEST_DONE();
+
+  TEST_BEGIN("lphush");
+  credis_del(redis, "credis1");
+  EXPECT_TRUE(credis_rpush(redis, "credis1", "element1") >= 0);
+  EXPECT_TRUE(credis_rpush(redis, "credis1", "element2") >= 0);
+  TEST_DONE();
+
+  TEST_BEGIN("llen");
+  credis_del(redis, "credis1");
+  EXPECT_EQ(credis_llen(redis, "credis1"), 0);
+  EXPECT_TRUE(credis_rpush(redis, "credis1", "element1") >= 0);
+  EXPECT_EQ(credis_llen(redis, "credis1"), 1);
+  EXPECT_TRUE(credis_rpush(redis, "credis1", "element2") >= 0);
+  EXPECT_EQ(credis_llen(redis, "credis1"), 2);
+  EXPECT_EQ(credis_del(redis, "credis1"), 0);
+  EXPECT_EQ(credis_set(redis, "credis1", "value1"), 0);
+  EXPECT_LT(credis_llen(redis, "credis1"), 0);
+  TEST_DONE();
+
+  TEST_BEGIN("lpop");
+  credis_del(redis, "credis1");
+  EXPECT_EQ(credis_lpop(redis, "credis1", &val), -1);
+  EXPECT_TRUE(credis_rpush(redis, "credis1", "element1") >= 0);
+  EXPECT_TRUE(credis_rpush(redis, "credis1", "element2") >= 0);
+  EXPECT_EQ(credis_lpop(redis, "credis1", &val), 0);
+  EXPECT_EQ(strcmp(val, "element1"), 0);
+  TEST_DONE();
+
+  TEST_BEGIN("rpop");
+  credis_del(redis, "credis1");
+  EXPECT_EQ(credis_rpop(redis, "credis1", &val), -1);
+  EXPECT_TRUE(credis_lpush(redis, "credis1", "element1") >= 0);
+  EXPECT_TRUE(credis_lpush(redis, "credis1", "element2") >= 0);
+  EXPECT_EQ(credis_rpop(redis, "credis1", &val), 0);
+  EXPECT_EQ(strcmp(val, "element1"), 0);
+  TEST_DONE();
+
+  TEST_BEGIN("lrange");
+  credis_del(redis, "credis1");
+  for (i = 0; i < keyc; i++)
+    EXPECT_TRUE(credis_rpush(redis, "credis1", values[i]) >= 0);
+  EXPECT_EQ(credis_lrange(redis, "credis1", 0, 10, &valv), keyc);
+  for (i = 0; i < keyc; i++)
+    EXPECT_EQ(strcmp(values[i], valv[i]), 0);
+  TEST_DONE();
+
+  TEST_BEGIN("ltrim");
+  credis_del(redis, "credis1");
+  for (i = 0; i < keyc; i++)
+    EXPECT_TRUE(credis_rpush(redis, "credis1", values[i]) >= 0);
+  EXPECT_EQ(credis_ltrim(redis, "credis1", 1, 3), 0);
+  EXPECT_EQ(credis_lrange(redis, "credis1", 0, 10, &valv), 3);
+  for (i = 1; i < 3; i++)
+    EXPECT_EQ(strcmp(values[i], valv[i - 1]), 0);
+  TEST_DONE();
+
+  TEST_BEGIN("lindex");
+  credis_del(redis, "credis1");
+  EXPECT_EQ(credis_lindex(redis, "credis1", 1, &val), -1);
+  for (i = 0; i < keyc; i++)
+    EXPECT_TRUE(credis_rpush(redis, "credis1", values[i]) >= 0);
+  EXPECT_EQ(credis_lindex(redis, "credis1", keyc + 1, &val), -1);
+  EXPECT_EQ(credis_lindex(redis, "credis1", 2, &val), 0);
+  EXPECT_EQ(strcmp(values[2], val), 0);
+  TEST_DONE();
+
+  TEST_BEGIN("lset");
+  credis_del(redis, "credis1");
+  EXPECT_EQ(credis_lindex(redis, "credis1", 1, &val), -1);
+  for (i = 0; i < keyc; i++)
+    EXPECT_TRUE(credis_rpush(redis, "credis1", values[i]) >= 0);
+  EXPECT_EQ(credis_lset(redis, "credis1", 3, "newvalue"), 0);
+  EXPECT_EQ(credis_lindex(redis, "credis1", 3, &val), 0);
+  EXPECT_EQ(strcmp("newvalue", val), 0);
+  EXPECT_LT(credis_lset(redis, "credis1", keyc + 1, "newvalue"), 0);
+  TEST_DONE();
+
+  TEST_BEGIN("lrem");
+  credis_del(redis, "credis1");
+  EXPECT_EQ(credis_lindex(redis, "credis1", 1, &val), -1);
+  for (i = 0; i < keyc; i++)
+    EXPECT_TRUE(credis_rpush(redis, "credis1", values[i]) >= 0);
+  EXPECT_EQ(credis_lrem(redis, "credis1", 0, values[1]), 1);
+  EXPECT_EQ(credis_lrem(redis, "credis1", 0, values[1]), 0);
+  TEST_DONE();
+
+#if 0
+
+
+  TEST_BEGIN("");
+  EXPECT_EQ(, 0);
+  TEST_DONE();
+
+  TEST_BEGIN("");
+  EXPECT_EQ(, 0);
+  TEST_DONE();
+
+  TEST_BEGIN("");
+  EXPECT_EQ(, 0);
+  TEST_DONE();
+
+  printf("Adding 200 items to list\n");
+  for (i = 0; i < 200; i++) {
+    char str[100];
+    sprintf(str, "%d%s%d", i, DUMMY_DATA, i);
+    rc = credis_rpush(redis, "mylist", str);
+    if (rc < 0)
+      printf("rpush returned: %d\n", rc);
+  }
+
+  rc = credis_lrange(redis, "mylist", 0, 200, &valv);
+  printf("lrange (0, 200) returned: %d, verifying data ... ", rc);
+  for (i = 0; i < rc; i++) {
+    char str[100];
+    sprintf(str, "%d%s%d", i, DUMMY_DATA, i);
+    if (strncmp(valv[i], str, strlen(str)))
+      printf("\nreturned item (%d) data differs: '%s' != '%s'", i, valv[i], str);
+  }  
+  printf("all data verified!\n");
+
+  printf("Testing lpush and lrem\n");
+  rc = credis_lpush(redis, "cars", "volvo");
+  rc = credis_lpush(redis, "cars", "saab");
+  rc = credis_lrange(redis, "cars", 0, 200, &valv);
+  printf("lrange (0, 200) returned: %d items\n", rc);
+  for (i = 0; i < rc; i++) 
+      printf("  %02d: %s\n", i, valv[i]);
+  rc = credis_lrem(redis, "cars", 1, "volvo");
+  printf("credis_lrem() returned %d\n", rc);
+  rc = credis_lrange(redis, "cars", 0, 200, &valv);
+  printf("lrange (0, 200) returned: %d items\n", rc);
+  for (i = 0; i < rc; i++) 
+      printf("  %02d: %s\n", i, valv[i]);
+  rc = credis_lrem(redis, "cars", 1, "volvo");
+
+  printf("Testing lset\n");
+  rc = credis_lset(redis, "cars", 2, "koenigsegg");
+  printf("lrange (0, 200) returned: %d items\n", rc);
+  for (i = 0; i < rc; i++) 
+      printf("  %02d: %s\n", i, valv[i]);
+  rc = credis_lrem(redis, "cars", 1, "volvo");
+#endif
+
+
+
+  TEST_RESULT();
+
+  return 0;
+}
+
 int main(int argc, char **argv) {
   REDIS redis;
   REDIS_INFO info;
@@ -79,6 +513,8 @@ int main(int argc, char **argv) {
   int rc, keyc=5, i;
   double score1, score2;
 
+  return test_suite2();
+
   redis = credis_connect(NULL, 0, 10000);
   if (redis == NULL) {
     printf("Error connecting to Redis server. Please start server to run tests.\n");
@@ -104,11 +540,18 @@ int main(int argc, char **argv) {
          "benchmark, run: `%s <num>' where <num> is the number\n"\
          "of set-commands to send.\n\n", argv[0]);
 
+
+
+
+#if 0
   printf("\n\n************* misc info ************************************ \n");
 
   rc = credis_ping(redis);
   printf("ping returned: %d\n", rc);
 
+  rc = credis_auth(redis, "qwerty");
+  printf("auth returned: %d\n", rc);
+
   rc = credis_lastsave(redis);
   printf("lastsave returned: %d\n", rc);
 
@@ -139,7 +582,6 @@ int main(int argc, char **argv) {
   printf("> vm_enabled: %d\n", info.vm_enabled);
   printf("> role: %d\n", info.role);
 
-
   printf("\n\n************* get/set ************************************ \n");
 
   rc = credis_set(redis, "kalle", "kula");
@@ -186,7 +628,6 @@ int main(int argc, char **argv) {
   for (i = 0; i < rc; i++)
     printf(" % 2d: %s\n", i, valv[i]);
 
-
   printf("\n\n************* sets ************************************ \n");
 
   rc = credis_sadd(redis, "fruits", "banana");
@@ -206,7 +647,7 @@ int main(int argc, char **argv) {
 
   rc = credis_srem(redis, "fruits", "orange");
   printf("srem returned: %d\n", rc);
-
+#endif
 
   printf("\n\n************* lists ************************************ \n");
 
@@ -271,7 +712,7 @@ int main(int argc, char **argv) {
     char str[100];
     sprintf(str, "%d%s%d", i, DUMMY_DATA, i);
     rc = credis_rpush(redis, "mylist", str);
-    if (rc != 0)
+    if (rc < 0)
       printf("rpush returned: %d\n", rc);
   }
 
@@ -307,6 +748,7 @@ int main(int argc, char **argv) {
       printf("  %02d: %s\n", i, valv[i]);
   rc = credis_lrem(redis, "cars", 1, "volvo");
 
+  return 0;
 
 
   printf("\n\n************* sorted sets ********************************** \n");
diff -rupN credis-0.2.3/credis.c credis-trunk/credis.c
--- credis-0.2.3/credis.c	2010-08-27 04:57:25.000000000 -0400
+++ credis-trunk/credis.c	2014-01-17 11:41:11.000000000 -0500
@@ -1,6 +1,6 @@
 /* credis.c -- a C client library for Redis
  *
- * Copyright (c) 2009-2010, Jonas Romfelt <jonas at romfelt dot se>
+ * Copyright (c) 2009-2012, Jonas Romfelt <jonas at romfelt dot se>
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -34,6 +34,9 @@
 #define WIN32_LEAN_AND_MEAN
 #include <winsock2.h>
 #else 
+#ifdef __FreeBSD__
+#include <sys/types.h>
+#endif
 #include <arpa/inet.h>
 #include <errno.h>
 #include <fcntl.h>
@@ -59,11 +62,15 @@ void close(int fd) {
 }
 #endif
 
+#define CR_VERSION(x,y,z) ((x) * 10000 + (y) * 100 + (z))
+
 #define CR_ERROR '-'
 #define CR_INLINE '+'
 #define CR_BULK '$'
 #define CR_MULTIBULK '*'
 #define CR_INT ':'
+#define CR_ANY '?'
+#define CR_NONE ' '
 
 #define CR_BUFFER_SIZE 4096
 #define CR_BUFFER_WATERMARK ((CR_BUFFER_SIZE)/10+1)
@@ -108,18 +115,32 @@ typedef struct _cr_multibulk { 
 } cr_multibulk;
 
 typedef struct _cr_reply {
+  char type;
   int integer;
   char *line;
   char *bulk;
   cr_multibulk multibulk;
 } cr_reply;
 
+typedef struct _cr_message { 
+  char *pattern;
+  char *channel;
+  char *message;
+  struct _cr_message *next; 
+} cr_message;
+
 typedef struct _cr_redis {
   struct {
     int major;
     int minor;
     int patch;
+    int number; /* holds a version number created by CR_VERSION() */
   } version;
+  struct {
+    cr_message *head;
+    cr_message *tail;
+    cr_message *msg;
+  } pubsub;
   int fd;
   char *ip;
   int port;
@@ -129,6 +150,7 @@ typedef struct _cr_redis {
   int error;
 } cr_redis;
 
+static void cr_freeallmessages(REDIS rhnd);
 
 /* Returns pointer to the '\r' of the first occurence of "\r\n", or NULL
  * if not found */
@@ -199,7 +221,7 @@ static int cr_morebulk(cr_multibulk *mb,
  * Returns:
  *   0  on success
  *  <0  on error, i.e. more memory not available */
-static int cr_splitstrtromultibulk(REDIS rhnd, char *str, const char token)
+static int cr_splitstrtomultibulk(REDIS rhnd, char *str, const char token)
 {
   int i = 0;
 
@@ -224,6 +246,7 @@ static int cr_splitstrtromultibulk(REDIS
  * Returns:
  *   0  on success
  *  <0  on error, i.e. more memory not available */
+__attribute__ ((format(printf,2,3)))
 static int cr_appendstrf(cr_buffer *buf, const char *format, ...)
 {
   int rc, avail;
@@ -235,16 +258,29 @@ static int cr_appendstrf(cr_buffer *buf,
   rc = vsnprintf(buf->data + buf->len, avail, format, ap);
   va_end(ap);
 
-  if (rc < 0)
+  if (rc < 0) {
+#ifdef WIN32
+    rc = avail * 2;
+#else
     return -1;
+#endif
+  }
 
-  if (rc >= avail) {
+  while (rc >= avail) {
     if (cr_moremem(buf, rc - avail + 1))
       return CREDIS_ERR_NOMEM;
 
     va_start(ap, format);
     rc = vsnprintf(buf->data + buf->len, buf->size - buf->len, format, ap);
     va_end(ap);
+
+    if (rc < 0) {
+#ifdef WIN32
+      rc = avail * 2;
+#else
+      return -1;
+#endif
+    }
   }
   buf->len += rc;
 
@@ -450,6 +486,7 @@ static int cr_readln(REDIS rhnd, int sta
 static int cr_receivemultibulk(REDIS rhnd, char *line) 
 {
   int bnum, blen, i, rc=0, idx;
+  char type;
 
   bnum = atoi(line);
 
@@ -463,19 +500,24 @@ static int cr_receivemultibulk(REDIS rhn
       return CREDIS_ERR_NOMEM;
   }
 
-  for (i = 0; bnum > 0 && (rc = cr_readln(rhnd, 0, &line, NULL)) > 0; i++, bnum--) {
-    if (*(line++) != CR_BULK)
-      return CREDIS_ERR_PROTOCOL;
-    
-    blen = atoi(line);
-    if (blen == -1)
-      rhnd->reply.multibulk.idxs[i] = -1;
-    else {
-      if ((rc = cr_readln(rhnd, blen, &line, &idx)) != blen)
-        return CREDIS_ERR_PROTOCOL;
-
-      rhnd->reply.multibulk.idxs[i] = idx;
+  for (i = 0; bnum > 0 && (rc = cr_readln(rhnd, 0, &line, &idx)) > 0; i++, bnum--) {
+    type = *(line++);
+    if (type == CR_BULK) {
+      blen = atoi(line);
+      if (blen == -1)
+        rhnd->reply.multibulk.idxs[i] = -1;
+      else {
+        if ((rc = cr_readln(rhnd, blen, &line, &idx)) != blen)
+          return CREDIS_ERR_PROTOCOL;
+        
+        rhnd->reply.multibulk.idxs[i] = idx;
+      }
+    }
+    else if (type == CR_INT) {
+      rhnd->reply.multibulk.idxs[i] = idx + 1;
     }
+    else
+      return CREDIS_ERR_PROTOCOL;
   }
   
   if (bnum != 0) {
@@ -540,9 +582,11 @@ static int cr_receivereply(REDIS rhnd, c
   if (cr_readln(rhnd, 0, &line, NULL) > 0) {
     prefix = *(line++);
  
-    if (prefix != recvtype && prefix != CR_ERROR)
+    if (recvtype != CR_ANY && prefix != recvtype && prefix != CR_ERROR)
       return CREDIS_ERR_PROTOCOL;
 
+    rhnd->reply.type = prefix;
+
     switch(prefix) {
     case CR_ERROR:
       return cr_receiveerror(rhnd, line);
@@ -562,6 +606,7 @@ static int cr_receivereply(REDIS rhnd, c
 
 static void cr_delete(REDIS rhnd) 
 {
+  cr_freeallmessages(rhnd);
   if (rhnd->reply.multibulk.bulks != NULL)
     free(rhnd->reply.multibulk.bulks);
   if (rhnd->reply.multibulk.idxs != NULL)
@@ -609,7 +654,10 @@ static int cr_sendandreceive(REDIS rhnd,
     return CREDIS_ERR_TIMEOUT;
   }
 
-  return cr_receivereply(rhnd, recvtype);
+  if (recvtype != CR_NONE)
+    rc = cr_receivereply(rhnd, recvtype);
+
+  return rc;
 }
 
 /* Prepare message buffer for sending using a printf()-style formatting. */
@@ -624,10 +672,16 @@ static int cr_sendfandreceive(REDIS rhnd
   rc = vsnprintf(buf->data, buf->size, format, ap);
   va_end(ap);
 
-  if (rc < 0)
+  if (rc < 0) {
+#ifdef WIN32
+    /* handle the fact that vnsprintf() returns -1 if the buffer is too small */
+    rc = buf->size * 2;
+#else
     return -1;
+#endif
+  }
 
-  if (rc >= buf->size) {
+  while (rc >= buf->size) {
     DEBUG("truncated, get more memory and try again");
     if (cr_moremem(buf, rc - buf->size + 1))
       return CREDIS_ERR_NOMEM;
@@ -635,6 +689,14 @@ static int cr_sendfandreceive(REDIS rhnd
     va_start(ap, format);
     rc = vsnprintf(buf->data, buf->size, format, ap);
     va_end(ap);
+
+    if (rc < 0) {
+#ifdef WIN32
+      rc = buf->size * 2;
+#else
+      return -1;
+#endif
+    }
   }
 
   buf->len = rc;
@@ -659,11 +721,37 @@ void credis_close(REDIS rhnd)
   }
 }
 
+/* Requests Redis server information and tries to fill handle with server version 
+ * information */ 
+static int cr_getredisversion(REDIS rhnd)
+{
+  /* We can receive 2 version formats: x.yz and x.y.z, where x.yz was only used prior 
+   * first 1.1.0 release(?), e.g. stable releases 1.02 and 1.2.6 */
+  /* TODO check returned error string, "-ERR operation not permitted", to detect if 
+   * server require password? */
+  if (cr_sendfandreceive(rhnd, CR_BULK, "INFO\r\n") == 0) {
+    int items = sscanf(rhnd->reply.bulk,
+                       "redis_version:%d.%d.%d\r\n",
+                       &(rhnd->version.major),
+                       &(rhnd->version.minor),
+                       &(rhnd->version.patch));
+    if (items == 2) {
+      rhnd->version.patch = rhnd->version.minor;
+      rhnd->version.minor = 0;
+    }
+    DEBUG("Connected to Redis version: %d.%d.%d\n", 
+          rhnd->version.major, rhnd->version.minor, rhnd->version.patch);
+
+    rhnd->version.number = CR_VERSION(rhnd->version.major, rhnd->version.minor, rhnd->version.patch);
+  }
+
+  return 0;
+}
+
 REDIS credis_connect(const char *host, int port, int timeout)
 {
-  int fd, rc, flags, yes = 1, use_he = 0;
+  int fd, rc, flags, yes = 1;
   struct sockaddr_in sa;  
-  struct hostent *he;
   REDIS rhnd;
 
 #ifdef WIN32
@@ -700,29 +788,35 @@ REDIS credis_connect(const char *host, i
   sa.sin_port = htons(port);
 
 #ifdef WIN32
+  struct hostent *he;
+
   /* TODO use getaddrinfo() instead! */
   addr = inet_addr(host);
-  if (addr == INADDR_NONE) {
+  if (addr == INADDR_NONE)
     he = gethostbyname(host);
-    use_he = 1;
-  }
-  else {
+  else
     he = gethostbyaddr((char *)&addr, sizeof(addr), AF_INET);
-    use_he = 1;
-  }
+
+  if (he == NULL)
+    goto error;
+
+  memcpy(&sa.sin_addr, he->h_addr, sizeof(struct in_addr));
 #else
+  int err;
+  struct addrinfo hints, *info;
+ 
   if (inet_aton(host, &sa.sin_addr) == 0) {
-    he = gethostbyname(host);
-    use_he = 1;
+    memset(&hints, 0, sizeof(hints));
+    hints.ai_family = AF_INET;
+    hints.ai_socktype = SOCK_STREAM;
+    err = getaddrinfo(host, NULL, &hints, &info);
+    if (err)
+      DEBUG("getaddrinfo error: %s\n", gai_strerror(err));
+    memcpy(&sa.sin_addr.s_addr, &(info->ai_addr->sa_data[2]), sizeof(in_addr_t));
+    freeaddrinfo(info);
   }
 #endif
 
-  if (use_he) {
-    if (he == NULL)
-      goto error;
-    memcpy(&sa.sin_addr, he->h_addr, sizeof(struct in_addr));
-  } 
-
   /* connect with user specified timeout */
 
   flags = fcntl(fd, F_GETFL);
@@ -750,23 +844,8 @@ REDIS credis_connect(const char *host, i
   rhnd->fd = fd;
   rhnd->timeout = timeout;
 
-  /* We can receive 2 version formats: x.yz and x.y.z, where x.yz was only used prior 
-   * first 1.1.0 release(?), e.g. stable releases 1.02 and 1.2.6 */
-  if (cr_sendfandreceive(rhnd, CR_BULK, "INFO\r\n") == 0) {
-    int items = sscanf(rhnd->reply.bulk,
-                       "redis_version:%d.%d.%d\r\n",
-                       &(rhnd->version.major),
-                       &(rhnd->version.minor),
-                       &(rhnd->version.patch));
-    if (items < 2)
-      goto error;
-    if (items == 2) {
-      rhnd->version.patch = rhnd->version.minor;
-      rhnd->version.minor = 0;
-    }
-    DEBUG("Connected to Redis version: %d.%d.%d\n", 
-          rhnd->version.major, rhnd->version.minor, rhnd->version.patch);
-  }
+  if (cr_getredisversion(rhnd) != 0)
+    goto error;
 
   return rhnd;
 
@@ -774,7 +853,6 @@ error:
   if (fd > 0)
     close(fd);
   cr_delete(rhnd);
-
   return NULL;
 }
 
@@ -785,8 +863,22 @@ void credis_settimeout(REDIS rhnd, int t
 
 int credis_set(REDIS rhnd, const char *key, const char *val)
 {
-  return cr_sendfandreceive(rhnd, CR_INLINE, "SET %s %zu\r\n%s\r\n", 
-                            key, strlen(val), val);
+  if (rhnd->version.number >= CR_VERSION(2,2,2))
+    return cr_sendfandreceive(rhnd, CR_INLINE, "SET %s %s\r\n", 
+			      key, val);
+  else
+    return cr_sendfandreceive(rhnd, CR_INLINE, "SET %s %zu\r\n%s\r\n", 
+			      key, strlen(val), val);
+}
+
+int credis_setex(REDIS rhnd, const char *key, const char *val, int seconds)
+{
+  if (rhnd->version.number >= CR_VERSION(2,2,2))
+    return cr_sendfandreceive(rhnd, CR_INLINE, "SETEX %s %d %s\r\n",
+			      key, seconds, val);
+  else
+    return cr_sendfandreceive(rhnd, CR_INLINE, "SETEX %s %d %zu\r\n%s\r\n",
+			      key, seconds, strlen(val), val);
 }
 
 int credis_get(REDIS rhnd, const char *key, char **val)
@@ -801,9 +893,15 @@ int credis_get(REDIS rhnd, const char *k
 
 int credis_getset(REDIS rhnd, const char *key, const char *set_val, char **get_val)
 {
-  int rc = cr_sendfandreceive(rhnd, CR_BULK, "GETSET %s %zu\r\n%s\r\n", 
-                              key, strlen(set_val), set_val);
+  int rc;
 
+  if (rhnd->version.number >= CR_VERSION(2,2,2))
+    rc = cr_sendfandreceive(rhnd, CR_BULK, "GETSET %s %s\r\n", 
+			    key, set_val);
+  else
+    rc = cr_sendfandreceive(rhnd, CR_BULK, "GETSET %s %zu\r\n%s\r\n", 
+			    key, strlen(set_val), set_val);
+  
   if (rc == 0 && (*get_val = rhnd->reply.bulk) == NULL)
     return -1;
 
@@ -815,9 +913,37 @@ int credis_ping(REDIS rhnd) 
   return cr_sendfandreceive(rhnd, CR_INLINE, "PING\r\n");
 }
 
+int credis_echo(REDIS rhnd, const char *message, char **reply)
+{
+  int rc;
+
+  if (rhnd->version.number >= CR_VERSION(2,2,2))
+    rc = cr_sendfandreceive(rhnd, CR_BULK, "ECHO %s\r\n", 
+			    message);
+  else
+    rc = cr_sendfandreceive(rhnd, CR_BULK, "ECHO %zu\r\n%s\r\n", 
+			    strlen(message), message);
+  
+  if (rc == 0 && (*reply = rhnd->reply.bulk) == NULL)
+    return -1;
+
+  return rc;
+}
+
+int credis_quit(REDIS rhnd) 
+{
+  return cr_sendfandreceive(rhnd, CR_INLINE, "QUIT\r\n");
+}
+
 int credis_auth(REDIS rhnd, const char *password)
 {
-  return cr_sendfandreceive(rhnd, CR_INLINE, "AUTH %s\r\n", password);
+  int rc = cr_sendfandreceive(rhnd, CR_INLINE, "AUTH %s\r\n", password);
+
+  /* Request Redis server version once we have been authenticated */
+  if (rc == 0)
+    return cr_getredisversion(rhnd);
+
+  return rc;
 }
 
 static int cr_multikeybulkcommand(REDIS rhnd, const char *cmd, int keyc, 
@@ -853,7 +979,11 @@ static int cr_multikeystorecommand(REDIS
   if ((rc = cr_appendstrarray(buf, keyc, keyv, 1)) != 0)
     return rc;
 
-  return cr_sendandreceive(rhnd, CR_INLINE);
+  /* integer reply and not inline as documentation specifies */
+  if ((rc = cr_sendandreceive(rhnd, CR_INT)) == 0)
+    rc = rhnd->reply.integer;
+
+  return rc;
 }
 
 int credis_mget(REDIS rhnd, int keyc, const char **keyv, char ***valv)
@@ -863,8 +993,14 @@ int credis_mget(REDIS rhnd, int keyc, co
 
 int credis_setnx(REDIS rhnd, const char *key, const char *val)
 {
-  int rc = cr_sendfandreceive(rhnd, CR_INT, "SETNX %s %zu\r\n%s\r\n", 
-                              key, strlen(val), val);
+  int rc;
+
+  if (rhnd->version.number >= CR_VERSION(2,2,2))
+    rc = cr_sendfandreceive(rhnd, CR_INT, "SETNX %s %s\r\n", 
+			    key, val);
+  else
+    rc = cr_sendfandreceive(rhnd, CR_INT, "SETNX %s %zu\r\n%s\r\n", 
+			    key, strlen(val), val);
 
   if (rc == 0 && rhnd->reply.integer == 0)
     rc = -1;
@@ -911,8 +1047,14 @@ int credis_decrby(REDIS rhnd, const char
 
 int credis_append(REDIS rhnd, const char *key, const char *val)
 {
-  int rc = cr_sendfandreceive(rhnd, CR_INT, "APPEND %s %zu\r\n%s\r\n", 
-                              key, strlen(val), val);
+  int rc;
+
+  if (rhnd->version.number >= CR_VERSION(2,2,2))
+    rc = cr_sendfandreceive(rhnd, CR_INT, "APPEND %s %s\r\n", 
+			    key, val);
+  else 
+    rc = cr_sendfandreceive(rhnd, CR_INT, "APPEND %s %zu\r\n%s\r\n", 
+			    key, strlen(val), val);
                             
   if (rc == 0)
     rc = rhnd->reply.integer;
@@ -922,8 +1064,14 @@ int credis_append(REDIS rhnd, const char
 
 int credis_substr(REDIS rhnd, const char *key, int start, int end, char **substr)
 {
-  int rc = cr_sendfandreceive(rhnd, CR_BULK, "SUBSTR %s %d %d\r\n", 
-                              key, start, end);
+  int rc;
+
+  if (rhnd->version.number <= CR_VERSION(2,0,0))
+    rc = cr_sendfandreceive(rhnd, CR_BULK, "SUBSTR %s %d %d\r\n", 
+			    key, start, end);
+  else
+    rc = cr_sendfandreceive(rhnd, CR_BULK, "GETRANGE %s %d %d\r\n", 
+			    key, start, end);
 
   if (rc == 0 && substr) 
     *substr = rhnd->reply.bulk;
@@ -931,6 +1079,11 @@ int credis_substr(REDIS rhnd, const char
   return rc;                            
 }
 
+int credis_getrange(REDIS rhnd, const char *key, int start, int end, char **substr)
+{
+  return credis_substr(rhnd, key, start, end, substr);
+}
+
 int credis_exists(REDIS rhnd, const char *key)
 {
   int rc = cr_sendfandreceive(rhnd, CR_INT, "EXISTS %s\r\n", key);
@@ -972,26 +1125,45 @@ int credis_type(REDIS rhnd, const char *
 
 int credis_keys(REDIS rhnd, const char *pattern, char ***keyv)
 {
-  int rc = cr_sendfandreceive(rhnd, CR_BULK, "KEYS %s\r\n", pattern);
+  int rc;
 
-  if (rc == 0) {
-    /* server returns keys as space-separated strings, use multi-bulk 
-     * storage to store keys */
-    if ((rc = cr_splitstrtromultibulk(rhnd, rhnd->reply.bulk, ' ')) == 0) {
-      *keyv = rhnd->reply.multibulk.bulks;
-      rc = rhnd->reply.multibulk.len;
+  /* with Redis 2.0.0 keys-command returns a multibulk instead of bulk */
+  if (rhnd->version.number >= CR_VERSION(2,0,0)) {
+    rc = cr_sendfandreceive(rhnd, CR_MULTIBULK, "KEYS %s\r\n", pattern);
+  }
+  else {
+    if ((rc = cr_sendfandreceive(rhnd, CR_BULK, "KEYS %s\r\n", pattern)) == 0) {
+      /* server returns keys as space-separated strings, use multi-bulk 
+       * storage to store keys */
+      rc = cr_splitstrtomultibulk(rhnd, rhnd->reply.bulk, ' ');
     }
   }
 
+  if (rc == 0) {
+    *keyv = rhnd->reply.multibulk.bulks;
+    rc = rhnd->reply.multibulk.len;
+  }
+
   return rc;
 }
 
 int credis_randomkey(REDIS rhnd, char **key)
 {
-  int rc = cr_sendfandreceive(rhnd, CR_INLINE, "RANDOMKEY\r\n");
+  int rc;
 
-  if (rc == 0 && key) 
-    *key = rhnd->reply.line;
+  /* with Redis 2.0.0 randomkey-command returns a bulk instead of inline */
+  if (rhnd->version.number >= CR_VERSION(2,0,0)) {
+    rc = cr_sendfandreceive(rhnd, CR_BULK, "RANDOMKEY\r\n");
+
+    if (rc == 0 && key) 
+      *key = rhnd->reply.bulk;
+  }
+  else {
+    rc = cr_sendfandreceive(rhnd, CR_INLINE, "RANDOMKEY\r\n");
+
+    if (rc == 0 && key) 
+      *key = rhnd->reply.line;
+  }
 
   return rc;
 }
@@ -1045,8 +1217,27 @@ int credis_ttl(REDIS rhnd, const char *k
 
 static int cr_push(REDIS rhnd, int left, const char *key, const char *val)
 {
-  return cr_sendfandreceive(rhnd, CR_INLINE, "%s %s %zu\r\n%s\r\n", 
+  int rc;
+
+  if (rhnd->version.number >= CR_VERSION(2,0,0)) {
+    if (rhnd->version.number >= CR_VERSION(2,2,2)) {
+      rc = cr_sendfandreceive(rhnd, CR_INT, "%s %s %s\r\n", 
+			      left==1?"LPUSH":"RPUSH", key, val);
+    }
+    else {
+      rc = cr_sendfandreceive(rhnd, CR_INT, "%s %s %zu\r\n%s\r\n", 
+			      left==1?"LPUSH":"RPUSH", key, strlen(val), val);
+    }
+
+    if (rc == 0)
+      rc = rhnd->reply.integer;
+  }
+  else {
+    rc = cr_sendfandreceive(rhnd, CR_INLINE, "%s %s %zu\r\n%s\r\n", 
                             left==1?"LPUSH":"RPUSH", key, strlen(val), val);
+  }
+
+  return rc;
 }
 
 int credis_rpush(REDIS rhnd, const char *key, const char *val)
@@ -1100,14 +1291,29 @@ int credis_lindex(REDIS rhnd, const char
 
 int credis_lset(REDIS rhnd, const char *key, int index, const char *val)
 {
-  return cr_sendfandreceive(rhnd, CR_INLINE, "LSET %s %d %zu\r\n%s\r\n", 
-                            key, index, strlen(val), val);
+  if (rhnd->version.number >= CR_VERSION(2,2,2))
+    return cr_sendfandreceive(rhnd, CR_INLINE, "LSET %s %d %s\r\n", 
+			      key, index, val);
+  else
+    return cr_sendfandreceive(rhnd, CR_INLINE, "LSET %s %d %zu\r\n%s\r\n", 
+			      key, index, strlen(val), val);
 }
 
 int credis_lrem(REDIS rhnd, const char *key, int count, const char *val)
 {
-  return cr_sendfandreceive(rhnd, CR_INT, "LREM %s %d %zu\r\n%s\r\n", 
-                            key, count, strlen(val), val);
+  int rc;
+
+  if (rhnd->version.number >= CR_VERSION(2,2,2))
+    rc = cr_sendfandreceive(rhnd, CR_INT, "LREM %s %d %s\r\n", 
+			    key, count, val);
+  else
+    rc = cr_sendfandreceive(rhnd, CR_INT, "LREM %s %d %zu\r\n%s\r\n", 
+			    key, count, strlen(val), val);
+
+  if (rc == 0) 
+    rc = rhnd->reply.integer;
+
+  return rc;
 }
 
 static int cr_pop(REDIS rhnd, int left, const char *key, char **val)
@@ -1239,6 +1445,8 @@ int credis_info(REDIS rhnd, REDIS_INFO *
     cr_parseinfo(rhnd->reply.bulk, "hash_max_zipmap_value", "%zu", &(info->hash_max_zipmap_value));
     cr_parseinfo(rhnd->reply.bulk, "pubsub_channels", "%ld", &(info->pubsub_channels));
     cr_parseinfo(rhnd->reply.bulk, "pubsub_patterns", "%u", &(info->pubsub_patterns));
+    cr_parseinfo(rhnd->reply.bulk, "keyspace_hits", "%lld", &(info->keyspace_hits));
+    cr_parseinfo(rhnd->reply.bulk, "keyspace_misses", "%lld", &(info->keyspace_misses));
     cr_parseinfo(rhnd->reply.bulk, "vm_enabled", "%d", &(info->vm_enabled));
     cr_parseinfo(rhnd->reply.bulk, "role", "%c", &role);
 
@@ -1263,9 +1471,15 @@ int credis_slaveof(REDIS rhnd, const cha
 
 static int cr_setaddrem(REDIS rhnd, const char *cmd, const char *key, const char *member)
 {
-  int rc = cr_sendfandreceive(rhnd, CR_INT, "%s %s %zu\r\n%s\r\n", 
-                              cmd, key, strlen(member), member);
+  int rc;
 
+  if (rhnd->version.number >= CR_VERSION(2,2,2))
+    rc = cr_sendfandreceive(rhnd, CR_INT, "%s %s %s\r\n", 
+			    cmd, key, member);
+  else      
+    rc = cr_sendfandreceive(rhnd, CR_INT, "%s %s %zu\r\n%s\r\n", 
+			    cmd, key, strlen(member), member);
+  
   if (rc == 0 && rhnd->reply.integer == 0)
     rc = -1;
 
@@ -1295,8 +1509,14 @@ int credis_spop(REDIS rhnd, const char *
 int credis_smove(REDIS rhnd, const char *sourcekey, const char *destkey, 
                  const char *member)
 {
-  int rc = cr_sendfandreceive(rhnd, CR_INT, "SMOVE %s %s %s\r\n", 
-                              sourcekey, destkey, member);
+  int rc;
+
+  if (rhnd->version.number >= CR_VERSION(2,2,2))
+    rc = cr_sendfandreceive(rhnd, CR_INT, "SMOVE %s %s %s\r\n",  
+			    sourcekey, destkey, member);
+  else
+    rc = cr_sendfandreceive(rhnd, CR_INT, "SMOVE %s %s %zu\r\n%s\r\n",  
+			    sourcekey, destkey, strlen(member), member);
 
   if (rc == 0 && rhnd->reply.integer == 0)
     rc = -1;
@@ -1356,8 +1576,14 @@ int credis_smembers(REDIS rhnd, const ch
 
 int credis_zadd(REDIS rhnd, const char *key, double score, const char *member)
 {
-  int rc = cr_sendfandreceive(rhnd, CR_INT, "ZADD %s %f %zu\r\n%s\r\n", 
-                              key, score, strlen(member), member);
+  int rc;
+
+  if (rhnd->version.number >= CR_VERSION(2,2,2))
+    rc = cr_sendfandreceive(rhnd, CR_INT, "ZADD %s %f %s\r\n", 
+			    key, score, member);
+  else
+    rc = cr_sendfandreceive(rhnd, CR_INT, "ZADD %s %f %zu\r\n%s\r\n", 
+			    key, score, strlen(member), member);
 
   if (rc == 0 && rhnd->reply.integer == 0)
     rc = -1;
@@ -1367,8 +1593,14 @@ int credis_zadd(REDIS rhnd, const char *
 
 int credis_zrem(REDIS rhnd, const char *key, const char *member)
 {
-  int rc = cr_sendfandreceive(rhnd, CR_INT, "ZREM %s %zu\r\n%s\r\n", 
-                              key, strlen(member), member);
+  int rc;
+
+  if (rhnd->version.number >= CR_VERSION(2,2,2))
+    rc = cr_sendfandreceive(rhnd, CR_INT, "ZREM %s %s\r\n", 
+			    key, member);
+  else
+    rc = cr_sendfandreceive(rhnd, CR_INT, "ZREM %s %zu\r\n%s\r\n", 
+			    key, strlen(member), member);
 
   if (rc == 0 && rhnd->reply.integer == 0)
     rc = -1;
@@ -1379,8 +1611,14 @@ int credis_zrem(REDIS rhnd, const char *
 /* TODO what does Redis return if member is not member of set? */
 int credis_zincrby(REDIS rhnd, const char *key, double incr_score, const char *member, double *new_score)
 {
-  int rc = cr_sendfandreceive(rhnd, CR_BULK, "ZINCRBY %s %f %zu\r\n%s\r\n", 
-                              key, incr_score, strlen(member), member);
+  int rc;
+
+  if (rhnd->version.number >= CR_VERSION(2,2,2))
+    rc = cr_sendfandreceive(rhnd, CR_BULK, "ZINCRBY %s %f %s\r\n", 
+			    key, incr_score, member);
+  else
+    rc = cr_sendfandreceive(rhnd, CR_BULK, "ZINCRBY %s %f %zu\r\n%s\r\n", 
+			    key, incr_score, strlen(member), member);
 
   if (rc == 0 && new_score)
     *new_score = strtod(rhnd->reply.bulk, NULL);
@@ -1388,14 +1626,23 @@ int credis_zincrby(REDIS rhnd, const cha
   return rc;
 }
 
-/* TODO what does Redis return if member is not member of set? */
 static int cr_zrank(REDIS rhnd, int reverse, const char *key, const char *member)
 {
-  int rc = cr_sendfandreceive(rhnd, CR_BULK, "%s %s %zu\r\n%s\r\n", 
-                              reverse==1?"ZREVRANK":"ZRANK", key, strlen(member), member);
+  int rc;
 
-  if (rc == 0)
-    rc = atoi(rhnd->reply.bulk);
+  if (rhnd->version.number >= CR_VERSION(2,2,2))
+    rc = cr_sendfandreceive(rhnd, CR_ANY, "%s %s %s\r\n", 
+			    reverse==1?"ZREVRANK":"ZRANK", key, member);
+  else
+    rc = cr_sendfandreceive(rhnd, CR_ANY, "%s %s %zu\r\n%s\r\n", 
+			    reverse==1?"ZREVRANK":"ZRANK", key, strlen(member), member);
+
+  if (rc == 0) {
+    if (rhnd->reply.type == CR_INT)
+      rc = rhnd->reply.integer;
+    else
+      rc = -1;
+  }
 
   return rc;
 }
@@ -1433,6 +1680,29 @@ int credis_zrevrange(REDIS rhnd, const c
   return cr_zrange(rhnd, 1, key, start, end, elementv);
 }
 
+int cr_zrangebyscore(REDIS rhnd, int reverse, const char *key, double a, double b, char ***elementv)
+{
+  int rc = cr_sendfandreceive(rhnd, CR_MULTIBULK, "%s %s %f %f\r\n",
+                              reverse==1?"ZREVRANGEBYSCORE":"ZRANGEBYSCORE", key, a, b);
+
+  if (rc == 0) {
+    *elementv = rhnd->reply.multibulk.bulks;
+    rc = rhnd->reply.multibulk.len;
+  }
+
+  return rc;
+}
+
+int credis_zrangebyscore(REDIS rhnd, const char *key, double min, double max, char ***elementv)
+{
+  return cr_zrangebyscore(rhnd, 0, key, min, max, elementv);
+}
+
+int credis_zrevrangebyscore(REDIS rhnd, const char *key, double max, double min, char ***elementv)
+{
+  return cr_zrangebyscore(rhnd, 1, key, max, min, elementv);
+}
+
 int credis_zcard(REDIS rhnd, const char *key)
 {
   int rc = cr_sendfandreceive(rhnd, CR_INT, "ZCARD %s\r\n", key);
@@ -1449,8 +1719,14 @@ int credis_zcard(REDIS rhnd, const char 
 
 int credis_zscore(REDIS rhnd, const char *key, const char *member, double *score)
 {
-  int rc = cr_sendfandreceive(rhnd, CR_BULK, "ZSCORE %s %zu\r\n%s\r\n", 
-                              key, strlen(member), member);
+  int rc;
+
+  if (rhnd->version.number >= CR_VERSION(2,2,2))
+    rc = cr_sendfandreceive(rhnd, CR_BULK, "ZSCORE %s %s\r\n", 
+			    key, member);
+  else
+    rc = cr_sendfandreceive(rhnd, CR_BULK, "ZSCORE %s %zu\r\n%s\r\n", 
+			    key, strlen(member), member);
 
   if (rc == 0) {
     if (!rhnd->reply.bulk)
@@ -1494,7 +1770,7 @@ static int cr_zstore(REDIS rhnd, int int
 
   buf->len = 0;
   
-  if ((rc = cr_appendstrf(buf, "%s %s %d ", inter?"ZINTERSTORE":"ZUNIONSTORE", destkey, keyc)) != 0)
+  if ((rc = cr_appendstrf(buf, "%s %s %d", inter?"ZINTERSTORE":"ZUNIONSTORE", destkey, keyc)) != 0)
     return rc;
   if ((rc = cr_appendstrarray(buf, keyc, keyv, 0)) != 0)
     return rc;
@@ -1505,13 +1781,13 @@ static int cr_zstore(REDIS rhnd, int int
 
   switch (aggregate) {
   case SUM: 
-    rc = cr_appendstr(buf, "AGGREGATE SUM", 0);
+    rc = cr_appendstr(buf, " AGGREGATE SUM", 0);
     break;
   case MIN:
-    rc = cr_appendstr(buf, "AGGREGATE MIN", 0);
+    rc = cr_appendstr(buf, " AGGREGATE MIN", 0);
     break;
   case MAX:
-    rc = cr_appendstr(buf, "AGGREGATE MAX", 0);
+    rc = cr_appendstr(buf, " AGGREGATE MAX", 0);
     break;
   case NONE:
     ; /* avoiding compiler warning */
@@ -1539,3 +1815,280 @@ int credis_zunionstore(REDIS rhnd, const
 {
   return cr_zstore(rhnd, 0, destkey, keyc, keyv, weightv, aggregate);
 }
+
+int credis_hset(REDIS rhnd, const char *key, const char *field, const char *value)
+{
+  int rc;
+
+  if (rhnd->version.number >= CR_VERSION(2,2,2))
+    rc = cr_sendfandreceive(rhnd, CR_INT, "HSET %s %s %s\r\n",
+			    key, field, value);
+  else
+    rc = cr_sendfandreceive(rhnd, CR_INT, "HSET %s %s %zu\r\n%s\r\n", 
+			    key, field, strlen(value), value);
+
+  if (rc == 0 && rhnd->reply.integer == 0)
+    rc = -1;
+
+  return rc;
+}
+
+int credis_hget(REDIS rhnd, const char *key, const char *field, char **value)
+{
+  int rc;
+
+  if (rhnd->version.number >= CR_VERSION(2,2,2))
+    rc = cr_sendfandreceive(rhnd, CR_BULK, "HGET %s %s\r\n",
+			    key, field);
+  else
+    rc = cr_sendfandreceive(rhnd, CR_BULK, "HGET %s %zu\r\n%s\r\n", 
+			    key, strlen(field), field);
+
+  if (rc == 0 && (*value = rhnd->reply.bulk) == NULL)
+    return -1;
+
+  return rc;
+}
+
+int credis_hkeys(REDIS rhnd, const char *key, char ***fieldv)
+{
+  int rc = cr_sendfandreceive(rhnd, CR_MULTIBULK, "HKEYS %s\r\n", key);
+
+  if (rc == 0) {
+    rc = rhnd->reply.multibulk.len;
+    *fieldv = rhnd->reply.multibulk.bulks;
+  }
+
+  return rc;
+}
+
+int credis_hlen(REDIS rhnd, const char *key)
+{
+  int rc = cr_sendfandreceive(rhnd, CR_INT, "HLEN %s\r\n", key);
+
+  if (rc == 0)
+    rc = rhnd->reply.integer;
+
+  return rc;
+}
+
+int credis_hmget(REDIS rhnd, const char *key, int fieldc, const char **fieldv, char ***valv)
+{
+  cr_buffer *buf = &(rhnd->buf);
+  int rc, i;
+
+  buf->len = 0;
+
+  /* using the new unified request protocol */
+  rc = cr_appendstrf(buf, "*%i\r\n$5\r\nHMGET\r\n$%zu\r\n%s\r\n", fieldc + 2, strlen(key), key);
+  if (rc != 0)
+    return rc;
+  
+  /* add fields */
+  for (i = 0; i < fieldc; i++) {
+    if ((rc = cr_appendstrf(buf, "$%zu\r\n%s\r\n", strlen(fieldv[i]), fieldv[i])) != 0)
+      return rc;
+  }
+
+  if ((rc = cr_sendandreceive(rhnd, CR_MULTIBULK)) == 0) {
+    *valv = rhnd->reply.multibulk.bulks;
+    rc = rhnd->reply.multibulk.len;
+  }
+
+  return rc;
+}
+
+
+static void cr_freemessage(cr_message *msg)
+{
+  if (msg != NULL) {
+    if (msg->message != NULL)
+      free(msg->message);
+    if (msg->channel != NULL)
+      free(msg->channel);
+    if (msg->pattern != NULL)
+      free(msg->pattern);
+    free(msg);
+  }
+}
+
+/* returns first message in FIFO and removes it from queue but
+ * does not free memory. returns NULL if the queue is empty */
+static cr_message * cr_getmessage(REDIS rhnd)
+{
+  cr_message *msg = rhnd->pubsub.head;
+
+  if (rhnd->pubsub.head != NULL) {
+    if (rhnd->pubsub.head == rhnd->pubsub.tail) {
+      rhnd->pubsub.head = NULL;
+      rhnd->pubsub.tail = NULL;
+    }
+    else
+      rhnd->pubsub.head = rhnd->pubsub.head->next;
+  }
+
+  return msg;
+}
+
+static void cr_freeallmessages(REDIS rhnd)
+{
+  cr_message *msg;
+
+  if (rhnd->pubsub.msg != NULL) {
+    cr_freemessage(rhnd->pubsub.msg);
+    rhnd->pubsub.msg = NULL;
+  }
+
+  while ((msg = cr_getmessage(rhnd)) != NULL)
+    cr_freemessage(rhnd->pubsub.msg);
+}
+
+/* allocates and adds new message last in FIFO. if successful a 
+ * pointer to newly created message struct is returned else NULL 
+ * is returned. */
+static cr_message * cr_storemessage(REDIS rhnd, char *pattern, char *channel, char *message)
+{
+  cr_message *msg;
+
+  if ((msg = calloc(sizeof(cr_message), 1)) == NULL ||
+      (pattern != NULL && (msg->pattern = strdup(pattern)) == NULL) ||
+      (msg->channel = strdup(channel)) == NULL ||
+      (msg->message = strdup(message)) == NULL) {
+    DEBUG("out of memory\n");
+    cr_freemessage(msg);
+    return NULL;
+  }
+
+  if (rhnd->pubsub.tail != NULL)
+    rhnd->pubsub.tail->next = msg;
+
+  rhnd->pubsub.tail = msg;
+
+  if (rhnd->pubsub.head == NULL)
+    rhnd->pubsub.head = msg;
+  
+  return msg;
+}
+
+static int cr_parsepubsubmessage(REDIS rhnd, char **pattern, char **channel, char **message)
+{
+  if (rhnd->reply.multibulk.len >= 4 && 
+      !strcmp("pmessage", rhnd->reply.multibulk.bulks[0])) {
+    *pattern = rhnd->reply.multibulk.bulks[1];
+    *channel = rhnd->reply.multibulk.bulks[2];
+    *message = rhnd->reply.multibulk.bulks[3];
+  }
+  else if (rhnd->reply.multibulk.len >= 3 && 
+           !strcmp("message", rhnd->reply.multibulk.bulks[0])) {
+    *pattern = NULL;
+    *channel = rhnd->reply.multibulk.bulks[1];
+    *message = rhnd->reply.multibulk.bulks[2];
+  }
+  else
+    return CREDIS_ERR_PROTOCOL;
+
+  return 0;
+}
+
+/* wait for a specific pub/sub message, for instance the reply to an
+ * subscription request, and store (p)messages received during wait to
+ * message queue. returns number of channels/patterns subscribed to. */
+static int cr_sendandwaitforpubsub(REDIS rhnd, const char *command, const char *data)
+{
+  cr_buffer *buf = &(rhnd->buf);
+  char *pattern, *channel, *message;
+  int rc;
+
+  buf->len = 0;
+  
+  if (data != NULL)
+    rc = cr_appendstrf(buf, "%s %s\r\n", command, data);
+  else
+    rc = cr_appendstrf(buf, "%s\r\n", command);
+
+  /* send without receiving reply */
+  if (rc == 0)
+    rc = cr_sendandreceive(rhnd, CR_NONE);
+
+  /* wait for pushed messages */
+  /* TODO introduce a timeout */ 
+  while (rc == 0) {
+    if ((rc = cr_receivereply(rhnd, CR_MULTIBULK)) != 0)
+      return rc;
+
+    if (rhnd->reply.multibulk.len >= 3 && 
+        !strcasecmp(command, rhnd->reply.multibulk.bulks[0]) &&
+        !strcasecmp(data, rhnd->reply.multibulk.bulks[1])) {
+      return atoi(rhnd->reply.multibulk.bulks[2]);
+    }
+    else if (cr_parsepubsubmessage(rhnd, &pattern, &channel, &message) == 0) {
+      if (cr_storemessage(rhnd, pattern, channel, message) == NULL)
+        return CREDIS_ERR_NOMEM;
+    }
+    else
+      ; /* TODO out of order pub/sub message, return error or silently ignore? */
+  }
+
+  return rc;
+}
+
+int credis_subscribe(REDIS rhnd, const char *channel)
+{
+  return cr_sendandwaitforpubsub(rhnd, "SUBSCRIBE", channel);
+}
+
+int credis_unsubscribe(REDIS rhnd, const char *channel)
+{
+  return cr_sendandwaitforpubsub(rhnd, "UNSUBSCRIBE", channel);
+}
+
+int credis_psubscribe(REDIS rhnd, const char *pattern)
+{
+  return cr_sendandwaitforpubsub(rhnd, "PSUBSCRIBE", pattern);
+}
+
+int credis_punsubscribe(REDIS rhnd, const char *pattern)
+{
+  return cr_sendandwaitforpubsub(rhnd, "PUNSUBSCRIBE", pattern);
+}
+
+int credis_publish(REDIS rhnd, const char *channel, const char *message)
+{
+  int rc;
+
+  if (rhnd->version.number >= CR_VERSION(2,2,2))
+    rc = cr_sendfandreceive(rhnd, CR_INT, "PUBLISH %s %s\r\n", 
+			    channel, message);
+  else
+    rc = cr_sendfandreceive(rhnd, CR_INT, "PUBLISH %s %zu\r\n%s\r\n", 
+			    channel, strlen(message), message);
+
+  if (rc == 0)
+    rc = rhnd->reply.integer;
+
+  return rc;                            
+}
+
+int credis_listen(REDIS rhnd, char **pattern, char **channel, char **message)
+{
+  int rc;
+
+  if (rhnd->pubsub.msg != NULL)
+    cr_freemessage(rhnd->pubsub.msg);
+
+  /* check message queue first */
+  if ((rhnd->pubsub.msg = cr_getmessage(rhnd)) != NULL) {
+    *pattern = rhnd->pubsub.msg->pattern;
+    *channel = rhnd->pubsub.msg->channel;
+    *message = rhnd->pubsub.msg->message;
+    return 0;
+  }
+
+  /* wait for message */
+  if ((rc = cr_receivereply(rhnd, CR_MULTIBULK)) == 0)
+    rc = cr_parsepubsubmessage(rhnd, pattern, channel, message);
+
+  return rc;
+}
+
+
diff -rupN credis-0.2.3/credis.h credis-trunk/credis.h
--- credis-0.2.3/credis.h	2010-08-27 04:57:25.000000000 -0400
+++ credis-trunk/credis.h	2014-01-17 11:41:24.000000000 -0500
@@ -1,6 +1,6 @@
 /* credis.h -- a C client library for Redis, public API.
  *
- * Copyright (c) 2009-2010, Jonas Romfelt <jonas at romfelt dot se>
+ * Copyright (c) 2009-2012, Jonas Romfelt <jonas at romfelt dot se>
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -85,6 +85,7 @@ typedef struct _cr_redis* REDIS;
 #define CREDIS_ERR_RECV -95
 #define CREDIS_ERR_TIMEOUT -96
 #define CREDIS_ERR_PROTOCOL -97
+#define CREDIS_ERR_PUBSUB -98
 
 #define CREDIS_TYPE_NONE 1
 #define CREDIS_TYPE_STRING 2
@@ -128,6 +129,8 @@ typedef struct _cr_info {
   unsigned long hash_max_zipmap_value;
   long pubsub_channels;
   unsigned int pubsub_patterns;
+  long long keyspace_hits;
+  long long keyspace_misses;
   int vm_enabled;
   int role;
 } REDIS_INFO;
@@ -150,12 +153,14 @@ void credis_settimeout(REDIS rhnd, int t
 
 void credis_close(REDIS rhnd);
 
-void credis_quit(REDIS rhnd);
+int credis_quit(REDIS rhnd);
 
 int credis_auth(REDIS rhnd, const char *password);
 
 int credis_ping(REDIS rhnd);
 
+int credis_echo(REDIS rhnd, const char *message, char **reply);
+
 /* if a function call returns error it is _possible_ that the Redis server
  * replied with an error message. It is returned by this function. */
 char* credis_errorreply(REDIS rhnd);
@@ -213,6 +218,8 @@ int credis_flushall(REDIS rhnd);
 
 int credis_set(REDIS rhnd, const char *key, const char *val);
 
+int credis_setex(REDIS rhnd, const char *key, const char *val, int seconds);
+
 /* returns -1 if the key doesn't exists */
 int credis_get(REDIS rhnd, const char *key, char **val);
 
@@ -227,7 +234,6 @@ int credis_mget(REDIS rhnd, int keyc, co
 int credis_setnx(REDIS rhnd, const char *key, const char *val);
 
 /* TODO
- * SETEX key time value Set+Expire combo command
  * MSET key1 value1 key2 value2 ... keyN valueN set a multiple keys to multiple values in a single atomic operation
  * MSETNX key1 value1 key2 value2 ... keyN valueN set a multiple keys to multiple values in a single atomic operation if none of
  */
@@ -249,13 +255,21 @@ int credis_append(REDIS rhnd, const char
 
 int credis_substr(REDIS rhnd, const char *key, int start, int end, char **substr);
 
+/* is an alias for credis_substr(), the command SUBSTR was renamed to GETRANGE in Redis > 2.0
+ * but is automatically handled by credis */
+int credis_getrange(REDIS rhnd, const char *key, int start, int end, char **substr);
+
 
 /*
  * Commands operating on lists 
  */
 
+/* if Redis server version is 2.0 or later the number of elements inside the list 
+ * after the push operation is returned on success */
 int credis_rpush(REDIS rhnd, const char *key, const char *element);
 
+/* if Redis server version is 2.0 or later the number of elements inside the list 
+ * after the push operation is returned on success */
 int credis_lpush(REDIS rhnd, const char *key, const char *element);
 
 /* returns length of list */
@@ -350,8 +364,7 @@ int credis_zadd(REDIS rhnd, const char *
 /* returns -1 if the member was not a member of the sorted set */
 int credis_zrem(REDIS rhnd, const char *key, const char *member);
 
-/* returns -1 if the member was not a member of the sorted set, the score of the member after
- * the increment by `incr_score' is returned by `new_score' */
+/* the score of the member after the increment by `incr_score' is returned by `new_score' */
 int credis_zincrby(REDIS rhnd, const char *key, double incr_score, const char *member, double *new_score);
 
 /* returns the rank of the given member or -1 if the member was not a member of the sorted set */
@@ -365,6 +378,16 @@ int credis_zrevrank(REDIS rhnd, const ch
 int credis_zrange(REDIS rhnd, const char *key, int start, int end, char ***elementv);
 
 /* returns number of elements returned in vector `elementv' 
+ * TODO add support for LIMIT 
+ * TODO add support for WITHSCORES */
+int credis_zrangebyscore(REDIS rhnd, const char *key, double min, double max, char ***elementv);
+
+/* returns number of elements returned in vector `elementv' 
+ * TODO add support for LIMIT 
+ * TODO add support for WITHSCORES */
+int credis_zrevrangebyscore(REDIS rhnd, const char *key, double max, double min, char ***elementv);
+
+/* returns number of elements returned in vector `elementv' 
  * TODO add support for WITHSCORES */
 int credis_zrevrange(REDIS rhnd, const char *key, int start, int end, char ***elementv);
 
@@ -381,10 +404,6 @@ int credis_zremrangebyscore(REDIS rhnd, 
 /* returns number of elements removed or -1 if key does not exist */
 int credis_zremrangebyrank(REDIS rhnd, const char *key, int start, int end);
 
-/* TODO
- * ZRANGEBYSCORE key min max Return all the elements with score >= min and score <= max (a range query) from the sorted set
- */
-
 /* `keyc' is the number of keys stored in `keyv'. `weightv' is optional, if not 
  * NULL, `keyc' is also the number of weights stored in `weightv'. */
 int credis_zinterstore(REDIS rhnd, const char *destkey, int keyc, const char **keyv, 
@@ -399,15 +418,29 @@ int credis_zunionstore(REDIS rhnd, const
  * Commands operating on hashes
  */
 
+/* 1 is returned if the field already exists and its value is updated, 0 is 
+ * returned if the field is created */
+int credis_hset(REDIS rhnd, const char *key, const char *field, const char *value);
+
+/* returns -1 if key or field don't exist */
+int credis_hget(REDIS rhnd, const char *key, const char *field, char **value);
+
+/* returns number of field names returned in vector `fieldv'. 0 is returned if `key' 
+ * is empty or does not exist */
+int credis_hkeys(REDIS rhnd, const char *key, char ***fieldv);
+
+/* returns number of fields in the hash, or 0 if `key' does not exist */
+int credis_hlen(REDIS rhnd, const char *key);
+ 
+/* returns number of values returned in vector `valv'. `fieldc' is the number
+ * of fields stored in `fieldv'. */
+int credis_hmget(REDIS rhnd, const char *key, int fieldc, const char **fieldv, char ***valv);
+
 /* TODO
- * HSET key field value Set the hash field to the specified value. Creates the hash if needed.
- * HGET key field Retrieve the value of the specified hash field.
  * HMSET key field1 value1 ... fieldN valueN Set the hash fields to their respective values.
  * HINCRBY key field integer Increment the integer value of the hash at _key_ on _field_ with _integer_.
  * HEXISTS key field Test for existence of a specified field in a hash
  * HDEL key field Remove the specified field from a hash
- * HLEN key Return the number of items in a hash.
- * HKEYS key Return all the fields in a hash.
  * HVALS key Return all the values in a hash.
  * HGETALL key Return all the fields and associated values in a hash.
  */
@@ -431,12 +464,51 @@ int credis_sort(REDIS rhnd, const char *
 
 
 /*
- * Publish/Subscribe
- */
+ * Publish/Subscribe 
+ *
+ * !!EXPERIMENTAL!! Expect API and implementation to change until these
+ * lines are removed.
+ *
+ * The nature of the publish/subscribe messaging paradigm differs from the 
+ * rest of Redis, the main difference being messages are pushed to subscribing 
+ * clients. Credis tries to hide some of this de-coupling in order to make life
+ * easier for application programmers. All subscribe, unsubscribe and publish 
+ * function calls will return when an acknowledgement has been received or on 
+ * error (including timeout), just as all other Credis function calls that map 
+ * to Redis commands. If a message is pushed to the client while waiting for 
+ * an acknowledgement, to for instance a new subscription, that message is 
+ * stored on an internal FIFO. When the client is ready to receive messages a 
+ * call to listen function is made and if there is a message in the FIFO it is 
+ * immediately returned else Credis waits for a message being pushed from Redis.
+ *
+ * IMPORTANT! Note that while subscribing to one or more channels (or patterns) 
+ * the client is in a publish/subscribe state in which is not allowed to perform 
+ * other commands.
+ */
+
+/* On success the number of channels we are currently subscribed to is
+ * returned. */
+int credis_subscribe(REDIS rhnd, const char *channel);
+
+/* `channel' specifies the channel to unsubscribe from. If set to NULL
+ * all channels are unsubscribed from. On success the number of channels 
+ * we are currently subscribed to is returned. */
+int credis_unsubscribe(REDIS rhnd, const char *channel);
+
+/* On success the number of channels we are currently subscribed to is
+ * returned. */
+int credis_psubscribe(REDIS rhnd, const char *pattern);
+
+/* `pattern' specifies the channels to unsubscribe from. If set to NULL
+ * all are unsubscribed from. On success the number of channels we are 
+ * currently subscribed to is returned. */
+int credis_punsubscribe(REDIS rhnd, const char *pattern);
 
-/* TODO
- * SUBSCRIBE/UNSUBSCRIBE/PUBLISH Redis Public/Subscribe messaging paradigm implementation
- */
+/* On success the number of clients that received the message is returned */
+int credis_publish(REDIS rhnd, const char *channel, const char *message);
+
+/* Listen for messages from channels and/or patterns subscribed to */
+int credis_listen(REDIS rhnd, char **pattern, char **channel, char **message);
 
 
 /* 
